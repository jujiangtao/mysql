drop table if exists t1, t2;
set debug_sync='RESET';
create table t1 (n1 int, n2 int, n3 int,
key (n1, n2, n3),
key (n2, n3, n1),
key (n3, n1, n2)) engine=myisam;
create table t2 (i int);
alter table t1 disable keys;
insert into t1 values (1, 2, 3);
reset master;
set debug_sync='alter_table_enable_indexes SIGNAL parked WAIT_FOR go';
alter table t1 enable keys;;
set debug_sync='now WAIT_FOR parked';
insert into t2 values (1);
insert into t1 values (1, 1, 1);;
set debug_sync='now SIGNAL go';
include/show_binlog_events.inc
Log_name	Pos	Event_type	Server_id	End_log_pos	Info
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Query	#	#	use `test`; insert into t2 values (1)
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; alter table t1 enable keys
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Query	#	#	use `test`; insert into t1 values (1, 1, 1)
master-bin.000001	#	Query	#	#	COMMIT
drop tables t1, t2;
set debug_sync='RESET';
End of 5.0 tests
drop table if exists t1, t2, t3;
create table t1 (i int);
reset master;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
alter table t1 change i c char(10) default 'Test1';;
set debug_sync='now WAIT_FOR parked';
insert into t1 values ();;
set debug_sync='now SIGNAL go';
select * from t1;
c
Test1
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
alter table t1 change c vc varchar(100) default 'Test2';;
set debug_sync='now WAIT_FOR parked';
rename table t1 to t2;;
set debug_sync='now SIGNAL go';
drop table t2;
create table t1 (i int);
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
alter table t1 change i c char(10) default 'Test3', rename to t2;;
set debug_sync='now WAIT_FOR parked';
insert into t2 values();;
set debug_sync='now SIGNAL go';
select * from t2;
c
Test3
alter table t2 change c vc varchar(100) default 'Test2', rename to t1;;
rename table t1 to t3;
drop table t3;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
set debug_sync='RESET';
include/show_binlog_events.inc
Log_name	Pos	Event_type	Server_id	End_log_pos	Info
master-bin.000001	#	Query	#	#	use `test`; alter table t1 change i c char(10) default 'Test1'
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Query	#	#	use `test`; insert into t1 values ()
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; alter table t1 change c vc varchar(100) default 'Test2'
master-bin.000001	#	Query	#	#	use `test`; rename table t1 to t2
master-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t2` /* generated by server */
master-bin.000001	#	Query	#	#	use `test`; create table t1 (i int)
master-bin.000001	#	Query	#	#	use `test`; alter table t1 change i c char(10) default 'Test3', rename to t2
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Query	#	#	use `test`; insert into t2 values()
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; alter table t2 change c vc varchar(100) default 'Test2', rename to t1
master-bin.000001	#	Query	#	#	use `test`; rename table t1 to t3
master-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t3` /* generated by server */
End of 5.1 tests
#
# Bug#22681959 : SELECT ON I_S TABLES WITH CONCURRENT DDL MAY CRASH SERVER
# Bug#22285643 : I_S QUERIES OPENING TMP TABLES FROM ALTER INVALIDATES REFERENCE COUNTER
#
SET DEBUG_SYNC= 'RESET';
DROP SCHEMA IF EXISTS test_i_s;
CREATE SCHEMA test_i_s;
USE test_i_s;
CREATE TABLE t1(a INT) ENGINE=MYISAM;
# Create new connections
connect  con1,localhost,root,,;
connect  con2,localhost,root,,;
connect  con3,localhost,root,,;
connect  con4,localhost,root,,;
connect  con5,localhost,root,,;
connection default;
SET GLOBAL DEBUG='d,alter_table_after_rename';
SET DEBUG_SYNC=
'before_rename_in_dd SIGNAL blocked WAIT_FOR i_s_select';
SET DEBUG_SYNC=
'after_rename_in_dd SIGNAL blocked_2 WAIT_FOR i_s_select_2';
# Sending ALTER Command
ALTER TABLE t1 add column (c2 int);;
connection con1;
SET DEBUG_SYNC= 'now WAIT_FOR blocked';
SET DEBUG_SYNC=
'show_after_table_list_prep SIGNAL i_s_select WAIT_FOR blocked_2';
SELECT table_name FROM information_schema.partitions WHERE SUBSTR(table_name,1,1)='#';;
connection con2;
SET DEBUG_SYNC= 'now SIGNAL i_s_select_2';
connection default;
#Reaping "ALTER ..."
connection con1;
#Reaping "SELECT"
table_name
SET DEBUG_SYNC= 'RESET';
SET GLOBAL DEBUG='';
connection con3;
USE test_i_s;
SET GLOBAL DEBUG='d,alter_table_after_rename';
SET DEBUG_SYNC=
'before_rename_in_dd SIGNAL blocked WAIT_FOR i_s_select';
# Sending:
ALTER TABLE t1 add column (c3 int);
connection con4;
SET DEBUG_SYNC= 'now WAIT_FOR blocked';
SET DEBUG_SYNC=
'after_acquire_abstract_table SIGNAL i_s_select WAIT_FOR blocked_2';
SELECT table_name FROM information_schema.partitions WHERE table_schema='test_i_s' and table_name LIKE '#sql%\_%';
connection con5;
SET DEBUG_SYNC= 'now SIGNAL i_s_select';
connection con3;
#Reaping "ALTER ..."
SET DEBUG_SYNC= 'now SIGNAL blocked_2';
connection con4;
#Reaping "SELECT"
table_name
connection default;
SET DEBUG_SYNC= 'RESET';
SET GLOBAL DEBUG='';
connection default;
USE test_i_s;
CREATE TABLE pid_table(pid_no INT);
SET @conn_id= connection_id();
LOAD DATA LOCAL INFILE 'pid_file' INTO TABLE pid_table;
connection con1;
use test_i_s;
connection default;
SET @lock_wait_timeout_saved= @@lock_wait_timeout;
SET lock_wait_timeout = 1;
ALTER TABLE t1 add column (c4 int);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
connection con1;
UNLOCK TABLES;
connection default;
SET lock_wait_timeout = 1;
ALTER TABLE t1 add column (c4 int);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
connection con1;
disconnect con1;
disconnect con2;
disconnect con3;
disconnect con4;
disconnect con5;
connection default;
DROP SCHEMA test_i_s;
SET @@lock_wait_timeout= @lock_wait_timeout_saved;
